import numpy as np
from scipy.sparse.linalg import aslinearoperator
from scipy.linalg import solve_banded

def lanczos_tridiagonal(H, v0, m):
    r"""
    Perform the Lanczos tridiagonalization of a Hermitian operator :math:`H`
    starting from an initial vector :math:`v_0`, producing the diagonal
    coefficients :math:`\{\alpha_j\}` and off-diagonal coefficients
    :math:`\{\beta_j\}` of the associated Lanczos tridiagonal matrix.

    The Lanczos algorithm constructs an orthonormal Krylov basis
    :math:`\{ v_0, v_1, \ldots, v_{m-1} \}` defined by
    
    .. math::

        \mathcal{K}_m(H, v_0) =
        \mathrm{span}\{ v_0,\; H v_0,\; H^2 v_0,\; \ldots,\; H^{m-1} v_0 \}.

    In this basis, the projection of :math:`H` takes the tridiagonal form

    .. math::

        T_m =
        \begin{pmatrix}
            \alpha_0 & \beta_0  & 0        & \cdots \\
            \beta_0  & \alpha_1 & \beta_1  & \cdots \\
            0        & \beta_1  & \alpha_2 & \cdots \\
            \vdots   & \vdots   & \vdots   & \ddots
        \end{pmatrix},

    Parameters
    ----------
    H : (n,n) array-like or LinearOperator
        Hermitian operator for which the Lanczos projection is constructed.
    v0 : (n,) array-like
        Initial seed vector :math:`v_0`, which will be normalized internally.
    m : int
        Maximum number of Lanczos iterations (Krylov dimension).

    Returns
    -------
    alphas : (k,) ndarray
        Real diagonal coefficients :math:`\alpha_j` of the Lanczos tridiagonal matrix.
    betas : (k-1,) ndarray
        Real off-diagonal coefficients :math:`\beta_j`.  The length may be
        smaller than :math:`m-1` if a lucky breakdown occurs.
    """
    H = aslinearoperator(H)
    n = H.shape[0]
    v = v0 / np.linalg.norm(v0)
    
    alphas = np.zeros(m, dtype=float)
    betas  = np.zeros(m-1, dtype=float)

    w = H @ v
    alphas[0] = np.vdot(v, w).real
    w = w - alphas[0] * v

    for j in range(1, m):
        betas[j - 1] = np.linalg.norm(w)
        if betas[j - 1] == 0:
            # lucky breakdown: actual Krylov dimension < m
            return alphas[:j], betas[:j-1]
        v_old = v
        v = w / betas[j-1]
        w = H @ v - betas[j-1] * v_old
        alphas[j] = np.vdot(v, w).real
        w = w - alphas[j] * v

    return alphas, betas


def resolvent_from_tridiag(alphas, betas, C, norm_psi):
    r"""
    Compute the projected resolvent element

    .. math::
        g(C) = \langle \psi \,|\, (H + C I)^{-1} \,|\, \psi \rangle,

    using the Lanczos tridiagonal representation of :math:`H` based on
    Krylov vector `norm_psi`, real diagonal coefficients `alphas` and
    real diagonal coefficients betas.
    
    Parameters
    ----------
    alphas : (m,) array_like
        Diagonal Lanczos coefficients
    betas : (m-1,) array_like
        Off-diagonal Lanczos coefficients.
    C : complex
        Complex energy shift applied to the operator, yielding :math:`H + C I`.
    norm_psi : float
        Norm :math:`\|\psi\|` of the original input vector used in Lanczos.

    Returns
    -------
    gC : complex
        Approximation to the resolvent element
        :math:`\langle \psi | (H + C I)^{-1} | \psi \rangle`.

    """
    # Build banded form for T + C I
    m = len(alphas)
    # upper, diagonal, lower
    ab = np.zeros((3, m), dtype=complex)
    ab[1, :] = alphas + C          # main diagonal
    ab[0, 1:] = betas              # upper diag
    ab[2, :-1] = betas             # lower diag

    e1 = np.zeros(m, dtype=complex)
    e1[0] = 1.0

    y = solve_banded((1, 1), ab, e1)
    return norm_psi**2 * y[0]


def build_lanczos_resolvent(H, psi, m):
    r"""
    Construct a callable function that evaluates the projected resolvent

    .. math::
        g(C) = \langle \psi \,|\, (H + C I)^{-1} \,|\, \psi \rangle,

    Parameters
    ----------
    H : (n, n) array_like or LinearOperator
        Hermitian operator whose resolvent is to be approximated.
    psi : (n,) array_like
        State vector :math:`|\psi\rangle` defining the projected resolvent
        element.  Only the Krylov subspace generated by :math:`\psi` matters.
    m : int
        Number of Lanczos iterations (size of the tridiagonal projection).

    Returns
    -------
    g : callable
        A function ``g(C)`` that evaluates
        :math:`\langle \psi | (H + C I)^{-1} | \psi \rangle`
        using the Lanczos continued-fraction representation.

    """
    norm_psi = np.linalg.norm(psi)
    v0 = psi / norm_psi
    alphas, betas = lanczos_tridiagonal(H, v0, m)
    def g(C):
        return resolvent_from_tridiag(alphas, betas, C, norm_psi)
    return g